<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Technology</title>
    <!-- FSharp.Formatting Styles -->
    <link rel="stylesheet" type="text/css" media="screen" href="http://tech.jet.com/fsharp.formatting/tooltips.css" />
    <script type="text/javascript" src="http://tech.jet.com/javascripts/video.fix.js"></script>
    <script type="text/javascript" src="http://tech.jet.com/javascripts/ga.js"></script>
    <script type="text/javascript" src="http://tech.jet.com/fsharp.formatting/tooltips.js"></script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    <link rel="stylesheet" href="http://tech.jet.com/stylesheets/styles.css">
    <link rel="stylesheet" href="http://tech.jet.com/stylesheets/pygment_trac.css">
    <link rel="shortcut icon" href="http://tech.jet.com/images/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <script type="text/javascript">var switchTo5x=true;</script>
    <script type="text/javascript" src="http://w.sharethis.com/button/buttons.js"></script>
    <script type="text/javascript">stLight.options({publisher: "81ce46a6-ba61-410c-bb73-5204cc8efed1", doNotHash: true, doNotCopy: false, hashAddressBar: false});</script></head>
<body>
    <header>
        <div>
            <a href="http://tech.jet.com/index.html" style="vertical-align:middle;"><img src="http://tech.jet.com/images/jet_logo.png" style="max-height:50px;" /></a><span class="subtitle">Technology</span>
            <div class="social">
                <ul>
                    <li>
                        <a class="social-icons" href="https://twitter.com/jettechnology"></a>
                    </li>
                    <li>
                        <a class="social-icons" href="https://twitter.com/jet"></a>
                    </li>
                    <li>
                        <a class="social-icons" href="https://www.facebook.com/jet"></a>
                    </li>
                    <li>
                        <a class="social-icons" href="https://www.github.com/jet"></a>
                    </li>
                    <li>
                        <a class="social-icons" href="https://linkedin.com/company/jet-com"></a>
                    </li>
                    <li>
                        <a class="social-icons" href="https://plus.google.com/118328800025960082059/posts"></a>
                    </li>
                </ul>
            </div>
        </div>
    </header>
    <leftpanel class="smaller">
        <h2><a href="https://jet.com/about-us/join-our-crew">Join us!</a></h2>

        <a class="twitter-timeline" data-dnt="true" href="https://twitter.com/JetTechnology" data-widget-id="652521231367995392">Tweets by @JetTechnology</a>
        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
        <br/><br/>

<!--       <h2>Tags</h2>
            <a href="http://tech.jet.com/blog/tag/fsharp/index.html">f#</a>
            <a href="http://tech.jet.com/blog/tag/community/index.html">community</a>
            <a href="http://tech.jet.com/blog/tag/microservices/index.html">microservices</a>
            <a href="http://tech.jet.com/blog/tag/jetdotcom/index.html">jet.com</a>
            <a href="http://tech.jet.com/blog/tag/jet-technology/index.html">jet technology</a>
            <a href="http://tech.jet.com/blog/tag/jetdotcom-technology/index.html">jet.com technology</a>
            <a href="http://tech.jet.com/blog/tag/azure/index.html">azure</a>
            <a href="http://tech.jet.com/blog/tag/cloud/index.html">cloud</a>
            <a href="http://tech.jet.com/blog/tag/continuous-learning/index.html">continuous learning</a>
            <a href="http://tech.jet.com/blog/tag/cloud-services/index.html">cloud services</a>
            <a href="http://tech.jet.com/blog/tag/micro-services/index.html">micro services</a>
            <a href="http://tech.jet.com/blog/tag/interview/index.html">interview</a>
            <a href="http://tech.jet.com/blog/tag/chaos-engineering/index.html">chaos engineering</a>
            <a href="http://tech.jet.com/blog/tag/performance-engineering/index.html">performance engineering</a>
            <a href="http://tech.jet.com/blog/tag/teaching/index.html">teaching</a>
            <a href="http://tech.jet.com/blog/tag/javascript/index.html">javascript</a>
            <a href="http://tech.jet.com/blog/tag/web-design/index.html">web design</a>
            <a href="http://tech.jet.com/blog/tag/technology/index.html">technology</a>
            <a href="http://tech.jet.com/blog/tag/marketing-tech/index.html">marketing tech</a>
        <br />-->
        <h2>Videos we <3</h2>
        <p>
            <ul>
                    <li><a href="http://tech.jet.com/videos/2015/12-16-why-your-team-has-slowed-down-why-that-s-worse-than-you-think-and-how-to-fix-it/index.html">Why Your Team Has Slowed Down, Why That's Worse than You Think, and How to Fix it</a></li>
                    <li><a href="http://tech.jet.com/videos/2015/12-16-type-driven-development-mark-seemann-on-vimeo/index.html">Type-Driven Development - Mark Seemann on Vimeo</a></li>
                    <li><a href="http://tech.jet.com/videos/2015/12-03-real-time-democratizing-of-event-driven-big-data-on-vimeo/index.html">REAL-TIME DEMOCRATIZING OF EVENT-DRIVEN BIG DATA on Vimeo</a></li>
                    <li><a href="http://tech.jet.com/videos/2015/12-03-patterns-and-practices-for-real-world-event-driven-microservices-on-vimeo/index.html">PATTERNS AND PRACTICES FOR REAL-WORLD EVENT-DRIVEN MICROSERVICES on Vimeo</a></li>
                    <li><a href="http://tech.jet.com/videos/2015/12-03-lambda-days-2015-evelina-gabasova-understanding-cancer-behaviour-with-f-on-vimeo/index.html">Lambda Days 2015 - Evelina Gabasova - Understanding cancer behaviour with F# on Vimeo</a></li>
                    <li><a href="http://tech.jet.com/videos/2015/10-09-the-many-faces-of-apache-kafka-how-is-kafka-used-in-practice/index.html">The Many Faces of Apache Kafka: How is Kafka Used in Practice</a></li>
                    <li><a href="http://tech.jet.com/videos/2015/10-09-journey-to-the-intelligent-cloud-azurecon-2015-channel-9/index.html">Journey to the intelligent cloud | AzureCon 2015 | Channel 9</a></li>
                    <li><a href="http://tech.jet.com/videos/2015/09-02-the-next-generation-of-neural-networks/index.html">The Next Generation of Neural Networks</a></li>
                    <li><a href="http://tech.jet.com/videos/2015/08-19-domain-driven-design-f-and-types-skillscast-13th-march-2014/index.html">Domain Driven Design, F# and Types | SkillsCast | 13th March 2014</a></li>
                    <li><a href="http://tech.jet.com/videos/2015/08-18-jet-com-kumail-nanjiani-explains-how-the-new-shopping-club-works/index.html">Jet.com - Kumail Nanjiani Explains How The New Shopping Club Works</a></li>
            </ul>
<!--            <small><a href="http://tech.jet.com/videos/">See all</a></small> -->
        </p>
    </leftpanel>
    <section>
        
<h1>Microservices & Messaging</h1>
<small>
    Krishna Vangapandu &nbsp; &nbsp;| &nbsp; &nbsp;
    2016-01-26T10:49:42
        &nbsp;&nbsp;| &nbsp;&nbsp;microservices, F#
</small>
<br />
<span class='st_reddit'></span>
<span class='st_facebook'></span>
<span class='st_twitter'></span>
<span class='st_linkedin'></span>
<span class='st_googleplus'></span>
<span class='st_tumblr'></span>
<span class='st_instapaper'></span>
<span class='st_email'></span>
<div class="postbody">
    
<p>Microservices are used heavily at Jet. We blogged about this in the <a href="http://techgroup.jet.com/blog/2015/11-27-how-jet-build-microservices-with/index.html">past</a> and spoke about it in a <a href="https://vimeo.com/109343720">few</a> <a href="https://vimeo.com/144692770">presentations</a>. Microservices communicate with each other through remote procedure calls or asynchronous messaging.</p>

<h2>The Jet Microservice template</h2>

<p>Microservices in Jet typically follow the pattern described below.</p>

<ol>
<li><p>A set of <code>input</code> that this microservice can understand</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
<span class="k">type</span> <span onmouseout="hideTip(event, 'fs1', 1)" onmouseover="showTip(event, 'fs1', 1)" class="i">Input</span> <span class="o">=</span> 
    | <span onmouseout="hideTip(event, 'fs2', 2)" onmouseover="showTip(event, 'fs2', 2)" class="i">Shipped</span> <span class="k">of</span> <span class="i">MerchantOrderShipped</span> 
    | <span onmouseout="hideTip(event, 'fs3', 3)" onmouseover="showTip(event, 'fs3', 3)" class="i">Cancelled</span> <span class="k">of</span> <span class="i">MerchantOrderCancelled</span></pre>
</td>
</tr>
</table></li>
<li><p>A set of <code>output</code> that this microservice will generate.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l">1: </span>
<span class="l">2: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
<span class="k">type</span> <span onmouseout="hideTip(event, 'fs4', 4)" onmouseover="showTip(event, 'fs4', 4)" class="i">Output</span> <span class="o">=</span> 
      | <span onmouseout="hideTip(event, 'fs5', 5)" onmouseover="showTip(event, 'fs5', 5)" class="i">Update</span> <span class="k">of</span> <span class="i">Order</span></pre>
</td>
</tr>
</table></li>
<li><p>A <code>decode</code> phase that basically deserializes the incoming message on a pipe to an appropriate strongly typed input.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs6', 6)" onmouseover="showTip(event, 'fs6', 6)" class="i">decode</span> <span onmouseout="hideTip(event, 'fs7', 7)" onmouseover="showTip(event, 'fs7', 7)" class="i">msg</span> <span class="o">=</span> 
     <span class="k">match</span> <span onmouseout="hideTip(event, 'fs7', 8)" onmouseover="showTip(event, 'fs7', 8)" class="i">msg</span><span class="o">.</span><span class="i">eventType</span> <span class="k">with</span> 
    | <span class="s">&quot;</span><span class="s">Shipped</span><span class="s">&quot;</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs1', 9)" onmouseover="showTip(event, 'fs1', 9)" class="i">Input</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs2', 10)" onmouseover="showTip(event, 'fs2', 10)" class="i">Shipped</span>(<span onmouseout="hideTip(event, 'fs7', 11)" onmouseover="showTip(event, 'fs7', 11)" class="i">msg</span><span class="o">.</span><span class="i">payload</span> <span class="o">|&gt;</span> <span class="i">toMerchantOrderShipped</span>) 
    | <span class="s">&quot;</span><span class="s">Cancelled</span><span class="s">&quot;</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs1', 12)" onmouseover="showTip(event, 'fs1', 12)" class="i">Input</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs3', 13)" onmouseover="showTip(event, 'fs3', 13)" class="i">Cancelled</span> (<span onmouseout="hideTip(event, 'fs7', 14)" onmouseover="showTip(event, 'fs7', 14)" class="i">msg</span><span class="o">.</span><span class="i">payload</span> <span class="o">|&gt;</span> <span class="i">toMerchantOrderCancelled</span>)</pre>
</td>
</tr>
</table></li>
<li><p>A <code>handle</code> phase that takes an input, runs some business logic to calculate what side-effects should occur and generates the <code>Output</code> accordingly.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs8', 15)" onmouseover="showTip(event, 'fs8', 15)" class="i">handle</span> <span class="o">=</span> <span class="k">function</span>
    | <span onmouseout="hideTip(event, 'fs2', 16)" onmouseover="showTip(event, 'fs2', 16)" class="i">Shipped</span> (<span onmouseout="hideTip(event, 'fs9', 17)" onmouseover="showTip(event, 'fs9', 17)" class="i">mo</span>) <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs10', 18)" onmouseover="showTip(event, 'fs10', 18)" class="i">async</span> {
            <span class="c">//load the order</span>
            <span class="c">//update the order</span>
            <span class="k">return</span> <span onmouseout="hideTip(event, 'fs4', 19)" onmouseover="showTip(event, 'fs4', 19)" class="i">Output</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs5', 20)" onmouseover="showTip(event, 'fs5', 20)" class="i">Update</span>(<span class="i">updatedOrder</span>)
        }
    | <span onmouseout="hideTip(event, 'fs3', 21)" onmouseover="showTip(event, 'fs3', 21)" class="i">Cancelled</span> (<span onmouseout="hideTip(event, 'fs9', 22)" onmouseover="showTip(event, 'fs9', 22)" class="i">mo</span>) <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs10', 23)" onmouseover="showTip(event, 'fs10', 23)" class="i">async</span> {
            <span class="c">//load the order</span>
            <span class="c">//update the order</span>
            <span class="k">return</span> <span onmouseout="hideTip(event, 'fs4', 24)" onmouseover="showTip(event, 'fs4', 24)" class="i">Output</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs5', 25)" onmouseover="showTip(event, 'fs5', 25)" class="i">Update</span>(<span class="i">updatedOrder</span>)
        }</pre>
</td>
</tr>
</table></li>
<li><p>An <code>interpret</code> phase that takes an <code>Output</code> and executes the side-effects that the output usually represents.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs11', 26)" onmouseover="showTip(event, 'fs11', 26)" class="i">interpret</span> <span class="o">=</span> <span class="k">function</span>
    | <span onmouseout="hideTip(event, 'fs5', 27)" onmouseover="showTip(event, 'fs5', 27)" class="i">Update</span> <span onmouseout="hideTip(event, 'fs12', 28)" onmouseover="showTip(event, 'fs12', 28)" class="i">order</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs10', 29)" onmouseover="showTip(event, 'fs10', 29)" class="i">async</span> {
            <span class="c">//store the updated order in the source-of-truth</span>
            <span class="c">//or send a message to another microservice queue</span>
        }</pre>
</td>
</tr>
</table></li>
</ol>

<!--more-->

<p>Note that the <code>decode -&gt; handle -&gt; interpret</code> pipeline itself may be made of some time-consuming or blocking operations which is to be fed with messages that the microservice receives. Some of us use <a href="https://msdn.microsoft.com/en-us/data/gg577609.aspx">Reactive Extensions</a> to convert the incoming messages into observables which then gets fed into the pipeline. And a few of us use the <a href="http://fsprojects.github.io/FSharp.Control.AsyncSeq/library/AsyncSeq.html">AsyncSeq</a> library to pull the messages from the stream. Either way, one can feed the incoming messages either 1) serially, 2) in parallel or 3) in some partial order (hybrid).</p>

<h2>Communication between microservices</h2>

<p>When it comes to communication between microservices, there are so many options to chose from. The simplest option is to have each microservice expose some form of an endpoint that the other can connect to and communicate directly. This may be a viable approach for having synchronous communication between services. As long as the services are connected to each other on the network, this approach can work. For the synchronous communication to be reliable, both the microservices (sender and receiver) should be running. Service-to-service communication begins to get tricky when one microservice need to send the same message to multiple other microservices.</p>

<p>Asynchronous communication between microservices may be accomplished using message-passing. In most cases, some form of message broker is involved, which both the microservices talks to. The broker may provide additional features such as reliability, delivery guarantees, security, etc. This model can also help in PUB/SUB kind of scenario where multiple microservices may be interested in the same message. The broker can take care of routing the message to appropriate consumers. <a href="https://azure.microsoft.com/en-us/services/service-bus/">Azure Service Bus</a> is one such message broker which supports both traditional message queues as well publish-subscribe topics. <a href="http://kafka.apache.org">Kafka</a> is another popular messaging platform.</p>

<h2>Checkpoint &amp; delivery semantics</h2>

<p><a href="https://en.wikipedia.org/wiki/Application_checkpointing">Checkpointing</a> is a common technique used to build fault-tolerant systems. In case of reading messages from a queue/topic, we checkpoint the current position in the channel so that if the consuming process goes down; it can resume at where it left off instead of starting at the beginning. When reading messages from the channel, if we commit the checkpoint position before actually processing it, we get <code>at-most once delivery</code>. If we commit the position after processing the message, we get <code>at-least once delivery</code>. In systems such as Service Bus, checkpoint is not done explicitly. Instead the consumer is responsible to "remove" the message from the queue. The delivery guarantee will then depend on when the message is ack'd/removed - before processing (at-most once) or after processing (at-least once).</p>

<h2>Serial processing of incoming messages</h2>

<p>The simplest case to reason about is when we process messages one after the other. While serial processing gives you simplicity, the trade-off is the increased latency (Queuing theory 101 states latency is the time spent by the message waiting to be processed). Also, one could argue that serial processing does not fully take advantage of the underyling resources. But if you have to maintain the ordering of messages, then you will need some form of serial execution. Scaling out a microservice such as this, where serial/ordered execution is absolutely critical, will have its own set of challenges.</p>

<h2>Parallel processing of incoming messages</h2>

<p>Processing messages in parallel, as fast as they arrive is ideal provided ordering of messages is not a requirement. Processing every incoming message as it arrives may reduce the latency and also help with efficient utilization of resources. The implementation may also warrant some careful examination. One could easily overwhelm the underlying threading system by spawning an unbounded number of threads or break the threadpool by having to manage an overly large pool of threads. Depending on the underlying implementation, one may even need to limit the max number of messages being processed in parallel. Moreover, this breaks ordering among the incoming messages. If ordering of messages is not critical, then one could have multiple instances of these microservices working off the same queue (in a competing-consumer fashion).</p>

<h2>Hybrid model - partial order of messages</h2>

<p>A more realistic need may be to process all messages of a group (for example, a customer order) serially. Messages from different groups need not be executed in order. This gives the simplicity of reasoning as in serial execution - we know all messages of a customer order are processed one-by-one. This also brings in the efficiency of parallel processing. Now our microservice can process on multiple orders at once. We will still need to keep an eye on the parallelism at play. And the hybrid implementation will increase the code complexity as well.</p>

<p>The rest of the post discusses some techniques to do the hybrid processing of the messages on the queue.</p>

<h2>Partition for parallelism in the communication layer</h2>

<p>Consider microservice <code>A</code>, which generates output messages that microservice <code>B</code> needs to process.</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l">1: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
[<span class="i">A</span>] <span class="o">==========</span> [<span class="i">B</span>]</pre>
</td>
</tr>
</table>

<p>Instead of using one queue for communication; <code>A</code> can write to <code>n</code> queues.</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
    <span class="o">==========</span>
    <span class="o">==========</span>
[<span class="i">A</span>]     <span class="o">.</span>      [<span class="i">B</span>]
        <span class="o">.</span>
    <span class="o">==========</span></pre>
</td>
</tr>
</table>

<p>Each message can then go to one of the <code>n</code> queues depending on how you hash out its group identifier (say Customer Order ID). We can then run multiple instances of the microservice <code>B</code> (atmost <code>n</code>) and have it read inputs from one of more queues. These instances can all be on the same machine, if needed.</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
    <span class="o">==========</span> [<span class="i">B</span>]
    <span class="o">==========</span> [<span class="i">B</span>]
[<span class="i">A</span>]     <span class="o">.</span>       <span class="o">.</span>
        <span class="o">.</span>       <span class="o">.</span>
    <span class="o">==========</span> [<span class="i">B</span>]</pre>
</td>
</tr>
</table>

<p>An advantage of this model is that the producing &amp; consuming microservices can remain agnostic to overall setup of the services. You may still need to apply some additional techniques such as consistent hashing w/ virtual nodes to support a dynamic number of microservice <code>B</code> instances. But the downside remains that you will need to manage the <code>n</code> queues that are required for each <code>topic</code>.</p>

<p>Kafka's model of a topic &amp; partitions is a good fit here. The management of those <code>n</code> "queues" (actually, partitions) are handled within Kafka through partitions. The group ID of an outgoing message can be mapped as a partition key. The messages are then spread across multiple partitions while those of the same "group" are within the same partition. And a single instance of a microservice can process multiple partitions concurrently (within the same process) while maintaining order only within the partitions. The parallelism will then depend on the number of partitions you choose for a given topic.</p>

<h2>Parallelism within the microservice</h2>

<p>Partitions are not free. As explained in the confluent <a href="http://www.confluent.io/blog/how-to-choose-the-number-of-topicspartitions-in-a-kafka-cluster/">blog post</a>, the number of partitions can have an impact on the overall system. For example, increasing the number of partitions will increase the number of open file handles, the stress on IO and more. So one would eventually settle on a large enough number of partitions that meets the needs for distributing the workload across multiple instances of microservices.</p>

<p>If we need to push the boundaries further, we can use some instance local techniques to process messages within the partition in parallel and of-course maintaining order within the same group. We will look at a couple of ways to accomplish this..</p>

<h3>Parallelism using Actors</h3>

<p>Each microservice instance can internally have "P" actors - one for each group. Each message will be sent to one of those "P" actors. Within the actor (<code>MailboxProcessor</code> in F#), it can perform the <code>decode -&gt; handle -&gt; interpret</code> cycle. If the rate of incoming messages is high compared to the rate of processing, the messages gets accumulated inside the actor's mailbox (internal queue). Eventually having an unbounded queue as an actor's mailbox leads to more memory consumption which may increase message loss when the process goes down. An additional problem with an Actor is that there is no knowledge of when a message is actually received and processed by the actor. This makes coordination of "read position" on partition/queue more explicit and complex. One way around this problem is to have these P actors send a message to a single actor "K" whose responsibility it is to just update the read commit. In this case, tracking the checkpoint problem can be solved but backpressure still remains a problem unless handled explicitly.</p>

<p>This post - <a href="http://pchiusano.blogspot.com/2010/01/actors-are-not-good-concurrency-model.html">"Actors are not a good concurrency model"</a> offers more insights into additional factors to consider about the Actor model.</p>

<h3>Parallelism via Fork-Join model</h3>

<p>Our microservice local parallelism needs can be expressed with the flow:
1. Read N messages out of a single partition (queue, whatever) 
2. Partition these N messages across "P" groups while maintaining order within each group
3. Process each group in parallel
4. Once all groups are completed, commit the read position to some f(last position, N).
5. Repeat.</p>

<p>The above flow describes a <a href="https://en.wikipedia.org/wiki/Fork–join_model">Fork-Join concurrency model</a>. Now in a reactive environment, we wish to process messages as they arrive, but still have some form of the above model.</p>

<h4>a highly opinionated simplification</h4>

<p>Translating the above model, while further simplifying to reduce complexity, the incoming stream of messages can be processed as such:
1. As a message arrives, check the current state to see if it can be processed immediately. If not, "block" on the task that is processing a different message on the same group.
2. If yes, then check to see if we have reached the max level of concurrency. If yes, "block" until one of the other tasks are completed.
3. If no, then spawn a task that processes this message. Update the state to include this new task.</p>

<p>Consider the flow below.</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
                                     | <span class="k">-&gt;</span> <span class="o">..</span><span class="o">.</span> <span class="i">a2</span>  
[<span class="i">a6</span> <span class="i">a5</span> <span class="i">a4</span> <span class="i">b6</span> <span class="i">b5</span> <span class="i">b4</span> <span class="i">c6</span> <span class="i">c5</span> <span class="i">c4</span> <span class="i">a3</span> ] <span class="k">-&gt;</span>  | <span class="k">-&gt;</span> <span class="o">..</span><span class="o">.</span> <span class="i">b3</span>
                                     | <span class="k">-&gt;</span> <span class="o">..</span><span class="o">.</span> 
         [<span class="i">incoming</span> <span class="i">messages</span>]    <span class="o">&lt;-</span>   { <span class="o">-&gt;&gt;</span> <span class="i">state</span> <span class="o">&lt;&lt;-</span> }</pre>
</td>
</tr>
</table>

<p>On the left side of the flow, we have the incoming messages. On the right, each <code>-&gt; ...</code> indicates an execution and these executions forms the current state. The messages labeled with the same character belong to the same group (eg: a1, a2, a3 are one group and b1,b2, b3 form another group, etc). Order must be maintained within the group but messages across the groups can be executed in any order. From the current state, notice that <code>a2</code> and <code>b3</code> are being executed. The next message - <code>a3</code> cannot be executed since another message of the same group <code>a2</code> is actively being processed and thus we block until <code>a2</code> gets processed completely.</p>

<p>In the simplified model, we will not move to <code>c4</code> until the message before it (<code>a3</code>) gets dispatched for execution. Note that, when we extend this simplified model to support putting <code>a3</code> in some of queue and move over to the next message <code>c4</code>; we mimic the actor-style processing of messages mentioned in the previous section.</p>

<p>The simplified model does bring in additional challenges around accurately committing the read postion to get an <code>at-least once</code> delivery semantic. A simpler alternative would be to return back the Task that is processing the message and then set a continuation on the task that writes the message's position in the log/partition/queue as the commit-position. In some cases, when you restart the service, you may end up reading in duplicate messages. But still within the same <code>at-least once delivery</code> semantics.</p>

<p>So let us see what an F# function that handles the above model may look like:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
<span class="i">runParallelOrBlock</span> 
        <span class="c">//specify the level of parallelism</span>
        (<span class="i">parallelism</span><span class="o">:</span><span onmouseout="hideTip(event, 'fs13', 30)" onmouseover="showTip(event, 'fs13', 30)" class="i">int</span>)                 
        <span class="c">//can two inputs run simultaneously?</span>
        (<span class="i">canRunTogether</span><span class="o">:</span><span class="o">&#39;</span><span class="i">input</span> <span class="k">-&gt;</span> <span class="o">&#39;</span><span class="i">input</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs14', 31)" onmouseover="showTip(event, 'fs14', 31)" class="i">bool</span>)
        <span class="c">//current state</span>
        (<span class="i">state</span><span class="o">:</span> (<span class="i">Task</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">b</span><span class="o">&gt;</span><span class="o">*</span><span class="o">&#39;</span><span class="i">input</span>) <span onmouseout="hideTip(event, 'fs15', 32)" onmouseover="showTip(event, 'fs15', 32)" class="i">array</span>)           
        <span class="c">//action to execute on the input</span>
        (<span class="i">f</span><span class="o">:</span><span class="o">&#39;</span><span class="i">input</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs16', 33)" onmouseover="showTip(event, 'fs16', 33)" class="i">Async</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">b</span><span class="o">&gt;</span>)         
        <span class="c">//current input           </span>
        (<span class="i">args</span><span class="o">:</span><span class="o">&#39;</span><span class="i">input</span>)                              
        <span class="c">//task for the current input, new state</span>
        <span class="o">:</span> <span class="i">Task</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">b</span><span class="o">&gt;</span> <span class="o">*</span> (<span class="i">Task</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">b</span><span class="o">&gt;</span> <span class="o">*</span> <span class="o">&#39;</span><span class="i">input</span>) <span onmouseout="hideTip(event, 'fs15', 34)" onmouseover="showTip(event, 'fs15', 34)" class="i">array</span>     </pre>
</td>
</tr>
</table>

<p>The functional way of managing state is to pass the current state as a parameter and then have the function return back the updated state.</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l">1: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
<span class="k">let</span> (<span class="i">result</span>, <span class="i">updatedState</span>) <span class="o">=</span> <span class="i">update</span> <span class="i">currentState</span> <span class="i">currentArgs</span></pre>
</td>
</tr>
</table>

<p>We follow the same pattern for our function <code>runParallelOrBlock</code>. A template implementation for such a function can be as:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
<span class="l">15: </span>
<span class="l">16: </span>
<span class="l">17: </span>
<span class="l">18: </span>
<span class="l">19: </span>
<span class="l">20: </span>
<span class="l">21: </span>
<span class="l">22: </span>
<span class="l">23: </span>
<span class="l">24: </span>
<span class="l">25: </span>
<span class="l">26: </span>
<span class="l">27: </span>
<span class="l">28: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
<span class="k">let</span> <span class="i">runParallelOrBlock</span> <span class="i">parallelism</span> <span class="i">canRunTogether</span> <span class="i">state</span> <span class="i">f</span> <span class="i">args</span> <span class="o">=</span>             
  <span class="c">//clean up the state to remove any tasks that are already completed.</span>
  <span class="k">let</span> <span class="i">newState</span> <span class="o">=</span> (<span class="i">state</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs17', 35)" onmouseover="showTip(event, 'fs17', 35)" class="i">Array</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs18', 36)" onmouseover="showTip(event, 'fs18', 36)" class="i">filter</span> (<span class="k">fun</span> (<span class="i">x</span>,_) <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs19', 37)" onmouseover="showTip(event, 'fs19', 37)" class="i">not</span> <span class="i">x</span><span class="o">.</span><span class="i">IsCompleted</span>)) 

  <span class="c">//check if we should block</span>
  <span class="k">let</span> <span class="i">doBlock</span> <span class="o">=</span> <span class="i">block</span> <span class="i">canRunTogether</span> <span class="i">state</span> <span class="i">args</span>

  <span class="c">//if we are to block, then we block. Otherwise, we will proceed to execution</span>
  <span class="k">if</span> <span class="i">doBlock</span> <span class="k">then</span>          
      <span class="i">waitForCompletion</span> <span class="i">state</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs20', 38)" onmouseover="showTip(event, 'fs20', 38)" class="i">ignore</span>
      <span class="c">//when we reach here, we are good to go</span>
      <span class="k">let</span> <span class="i">task</span> <span class="o">=</span> <span class="i">execute</span> <span class="i">f</span> <span class="i">args</span>
      <span class="i">task</span>, [||]
  <span class="k">else</span>
      <span class="k">let</span> <span class="k">rec</span> <span class="i">innerRun</span> (<span class="i">current</span><span class="o">:</span>_ []) <span class="o">=</span> 
          <span class="k">let</span> <span class="i">currentLimit</span> <span class="o">=</span> <span class="i">current</span><span class="o">.</span><span class="i">Length</span>
          <span class="c">//if we are at the concurrency limit, we block. Else we execute</span>
          <span class="k">if</span> <span class="i">currentLimit</span> <span class="o">&lt;</span> <span class="i">parallelism</span> <span class="k">then</span>
              <span class="k">let</span> <span class="i">task</span> <span class="o">=</span> <span class="i">execute</span> <span class="i">f</span> <span class="i">args</span>
              <span class="i">task</span>, <span onmouseout="hideTip(event, 'fs17', 39)" onmouseover="showTip(event, 'fs17', 39)" class="i">Array</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs21', 40)" onmouseover="showTip(event, 'fs21', 40)" class="i">append</span> <span class="i">current</span> [|(<span class="i">task</span>, <span class="i">args</span>)|]
          <span class="k">else</span>
              <span class="c">//we are at concurrency limits, wait for any task and try again.</span>
              <span class="i">waitForAny</span> <span class="i">current</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs20', 41)" onmouseover="showTip(event, 'fs20', 41)" class="i">ignore</span>
              <span class="i">current</span> 
              <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs17', 42)" onmouseover="showTip(event, 'fs17', 42)" class="i">Array</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs18', 43)" onmouseover="showTip(event, 'fs18', 43)" class="i">filter</span> (<span class="k">fun</span> (<span class="i">x</span>,_) <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs19', 44)" onmouseover="showTip(event, 'fs19', 44)" class="i">not</span> <span class="i">x</span><span class="o">.</span><span class="i">IsCompleted</span>)
              <span class="o">|&gt;</span> <span class="i">innerRun</span>

      <span class="i">innerRun</span> <span class="i">newState</span></pre>
</td>
</tr>
</table>

<p>We can delegate the responsibility of managing the state to the consumer of this function. 
The usage can be something like :</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l">1: </span>
<span class="l">2: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
<span class="k">let</span> <span class="i">task</span>, <span class="i">state</span> <span class="o">=</span> 
    <span class="i">runParallelOrBlock</span> <span class="n">8</span> <span class="i">canBeParallel</span> [||] (<span onmouseout="hideTip(event, 'fs8', 45)" onmouseover="showTip(event, 'fs8', 45)" class="i">handle</span> <span class="o">&gt;</span><span class="o">&gt;</span> <span onmouseout="hideTip(event, 'fs16', 46)" onmouseover="showTip(event, 'fs16', 46)" class="i">Async</span><span class="o">.</span><span class="i">bind</span>(<span class="i">interpret</span>)) <span class="i">currentMessage</span></pre>
</td>
</tr>
</table>

<p>So the caller can keep track of the <code>state</code> returned and reuse it during the subsequent calls. The state in this case is basically a collection of running tasks.
We can have the <code>runParallelOrBlock</code> take care of cleaning up the state so as to remove any tasks that are completed. We can also use the <code>task</code> and the <code>input</code> together to decide when to set the commit position.</p>

<p>As mentioned earlier, if we look at incoming messages as a stream, an <a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">FRP</a>-style of state management would be to <code>fold</code> over the stream. The <code>fold</code> takes care of maintaining the state and passes the latest state for the next iteration. The function passed to the fold is expected to return an updated state back. <code>IObservable&lt;T&gt;</code> is one way to have a stream of messages and the Rx API has support for functional folds.</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
<span class="l">8: </span>
<span class="l">9: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
<span class="c">//functional style to keep state around is to fold over the inputs and keep the latest state.</span>
<span class="c">//hence the aggregate</span>
<span class="k">let</span> <span class="i">initialState</span> <span class="o">=</span> [||]               
<span class="i">stream</span><span class="o">.</span><span class="i">SubscribeOn</span>(<span onmouseout="hideTip(event, 'fs22', 47)" onmouseover="showTip(event, 'fs22', 47)" class="i">System</span><span class="o">.</span><span class="i">Reactive</span><span class="o">.</span><span class="i">Concurrency</span><span class="o">.</span><span class="i">ThreadPoolScheduler</span><span class="o">.</span><span class="i">Instance</span>)
        <span class="o">.</span><span class="i">Aggregate</span>(<span class="i">initialState</span>, 
                    <span class="k">fun</span> <span class="i">state</span> (<span class="i">input</span>,_) <span class="k">-&gt;</span> 
                    <span class="k">let</span> (_,<span class="i">newState</span>) <span class="o">=</span> <span class="i">runner</span> <span class="i">state</span> <span class="i">processInput</span> <span class="i">input</span>
                    <span class="i">newState</span>)
        <span class="o">.</span><span class="i">RunAsync</span>(<span onmouseout="hideTip(event, 'fs22', 48)" onmouseover="showTip(event, 'fs22', 48)" class="i">System</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs23', 49)" onmouseover="showTip(event, 'fs23', 49)" class="i">Threading</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs24', 50)" onmouseover="showTip(event, 'fs24', 50)" class="i">CancellationToken</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs25', 51)" onmouseover="showTip(event, 'fs25', 51)" class="i">None</span>)</pre>
</td>
</tr>
</table>

<p>Note that the above implementation is highly opinionated &amp; simplified. But it can still be made to support any of the three ways to process the messages - serial, parallel, hybrid. To see how, lets define some helper functions.</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
<span class="k">module</span> <span class="i">Parallel</span> <span class="o">=</span> 
    <span class="k">let</span> <span class="i">Always</span> <span class="o">=</span> <span class="k">fun</span> _ _ <span class="k">-&gt;</span> <span class="k">true</span>
    <span class="k">let</span> <span class="i">Never</span>  <span class="o">=</span> <span class="k">fun</span> _ _ <span class="k">-&gt;</span> <span class="k">false</span></pre>
</td>
</tr>
</table>

<p>Now serial processing of messages can be as:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l">1: </span>
<span class="l">2: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
<span class="k">let</span> <span class="i">serialExecute</span> <span class="o">=</span> 
    <span class="i">runParallelOrBlock</span> <span class="n">1</span> <span class="i">Parallel</span><span class="o">.</span><span class="i">Never</span></pre>
</td>
</tr>
</table>

<p>Always parallel processing of messages can be as:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l">1: </span>
<span class="l">2: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
<span class="k">let</span> <span class="i">parallelExecute</span> <span class="o">=</span> 
    <span class="i">runParallelOrBlock</span> <span class="i">Environment</span><span class="o">.</span><span class="i">ProcessorCount</span> <span class="i">Parallel</span><span class="o">.</span><span class="i">Always</span></pre>
</td>
</tr>
</table>

<p>Additional concerns include testability, debuggability and logging. For example, logging from those actions running concurrently is a little tricky. In the simplest case where logs from all the actions goes to the same logger; statements from one action will be interleaved with those from the others. This makes log analysis tricky unless we log additional context/group information to the log statement.</p>

<h1>Conclusion</h1>

<p>Microservices and asynchronous messaging comes with an interesting set of challenges. While scale-out is one of the ways that message consumption throughput may be increased, it is worthwhile to have individual services be as efficient as they can be in processing the incoming messages. Message-ordering poses additional restrictions on when a message gets processed in addition to the existing challenges of reliability and fault-tolerance. A couple of ways to tackle this problem have been presented here - within a single service and across multiple services.</p>

<p><em>A big thanks to Jeremy Kimball, Scott Havens, Gad Berger and Rachel Reese for their suggestions to improve this post.</em></p>

<div class="tip" id="fs1">type Input =<br />&#160;&#160;| Shipped of obj<br />&#160;&#160;| Cancelled of obj<br /><br />Full name: microservicesmessaging.Input</div>
<div class="tip" id="fs2">union case Input.Shipped: obj -&gt; Input</div>
<div class="tip" id="fs3">union case Input.Cancelled: obj -&gt; Input</div>
<div class="tip" id="fs4">type Output = | Update of obj<br /><br />Full name: microservicesmessaging.Output</div>
<div class="tip" id="fs5">union case Output.Update: obj -&gt; Output</div>
<div class="tip" id="fs6">val decode : msg:&#39;a -&gt; Input<br /><br />Full name: microservicesmessaging.decode</div>
<div class="tip" id="fs7">val msg : &#39;a</div>
<div class="tip" id="fs8">val handle : _arg1:Input -&gt; Async&lt;Output&gt;<br /><br />Full name: microservicesmessaging.handle</div>
<div class="tip" id="fs9">val mo : obj</div>
<div class="tip" id="fs10">val async : AsyncBuilder<br /><br />Full name: Microsoft.FSharp.Core.ExtraTopLevelOperators.async</div>
<div class="tip" id="fs11">val interpret : _arg1:Output -&gt; &#39;a<br /><br />Full name: microservicesmessaging.interpret</div>
<div class="tip" id="fs12">val order : obj</div>
<div class="tip" id="fs13">Multiple items<br />val int : value:&#39;T -&gt; int (requires member op_Explicit)<br /><br />Full name: Microsoft.FSharp.Core.Operators.int<br /><br />--------------------<br />type int = int32<br /><br />Full name: Microsoft.FSharp.Core.int<br /><br />--------------------<br />type int&lt;&#39;Measure&gt; = int<br /><br />Full name: Microsoft.FSharp.Core.int&lt;_&gt;</div>
<div class="tip" id="fs14">type bool = System.Boolean<br /><br />Full name: Microsoft.FSharp.Core.bool</div>
<div class="tip" id="fs15">type &#39;T array = &#39;T []<br /><br />Full name: Microsoft.FSharp.Core.array&lt;_&gt;</div>
<div class="tip" id="fs16">Multiple items<br />type Async<br />static member AsBeginEnd : computation:(&#39;Arg -&gt; Async&lt;&#39;T&gt;) -&gt; (&#39;Arg * AsyncCallback * obj -&gt; IAsyncResult) * (IAsyncResult -&gt; &#39;T) * (IAsyncResult -&gt; unit)<br />static member AwaitEvent : event:IEvent&lt;&#39;Del,&#39;T&gt; * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt; (requires delegate and &#39;Del :&gt; Delegate)<br />static member AwaitIAsyncResult : iar:IAsyncResult * ?millisecondsTimeout:int -&gt; Async&lt;bool&gt;<br />static member AwaitTask : task:Task&lt;&#39;T&gt; -&gt; Async&lt;&#39;T&gt;<br />static member AwaitWaitHandle : waitHandle:WaitHandle * ?millisecondsTimeout:int -&gt; Async&lt;bool&gt;<br />static member CancelDefaultToken : unit -&gt; unit<br />static member Catch : computation:Async&lt;&#39;T&gt; -&gt; Async&lt;Choice&lt;&#39;T,exn&gt;&gt;<br />static member FromBeginEnd : beginAction:(AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member FromBeginEnd : arg:&#39;Arg1 * beginAction:(&#39;Arg1 * AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member FromBeginEnd : arg1:&#39;Arg1 * arg2:&#39;Arg2 * beginAction:(&#39;Arg1 * &#39;Arg2 * AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member FromBeginEnd : arg1:&#39;Arg1 * arg2:&#39;Arg2 * arg3:&#39;Arg3 * beginAction:(&#39;Arg1 * &#39;Arg2 * &#39;Arg3 * AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member FromContinuations : callback:((&#39;T -&gt; unit) * (exn -&gt; unit) * (OperationCanceledException -&gt; unit) -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member Ignore : computation:Async&lt;&#39;T&gt; -&gt; Async&lt;unit&gt;<br />static member OnCancel : interruption:(unit -&gt; unit) -&gt; Async&lt;IDisposable&gt;<br />static member Parallel : computations:seq&lt;Async&lt;&#39;T&gt;&gt; -&gt; Async&lt;&#39;T []&gt;<br />static member RunSynchronously : computation:Async&lt;&#39;T&gt; * ?timeout:int * ?cancellationToken:CancellationToken -&gt; &#39;T<br />static member Sleep : millisecondsDueTime:int -&gt; Async&lt;unit&gt;<br />static member Start : computation:Async&lt;unit&gt; * ?cancellationToken:CancellationToken -&gt; unit<br />static member StartAsTask : computation:Async&lt;&#39;T&gt; * ?taskCreationOptions:TaskCreationOptions * ?cancellationToken:CancellationToken -&gt; Task&lt;&#39;T&gt;<br />static member StartChild : computation:Async&lt;&#39;T&gt; * ?millisecondsTimeout:int -&gt; Async&lt;Async&lt;&#39;T&gt;&gt;<br />static member StartChildAsTask : computation:Async&lt;&#39;T&gt; * ?taskCreationOptions:TaskCreationOptions -&gt; Async&lt;Task&lt;&#39;T&gt;&gt;<br />static member StartImmediate : computation:Async&lt;unit&gt; * ?cancellationToken:CancellationToken -&gt; unit<br />static member StartWithContinuations : computation:Async&lt;&#39;T&gt; * continuation:(&#39;T -&gt; unit) * exceptionContinuation:(exn -&gt; unit) * cancellationContinuation:(OperationCanceledException -&gt; unit) * ?cancellationToken:CancellationToken -&gt; unit<br />static member SwitchToContext : syncContext:SynchronizationContext -&gt; Async&lt;unit&gt;<br />static member SwitchToNewThread : unit -&gt; Async&lt;unit&gt;<br />static member SwitchToThreadPool : unit -&gt; Async&lt;unit&gt;<br />static member TryCancelled : computation:Async&lt;&#39;T&gt; * compensation:(OperationCanceledException -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member CancellationToken : Async&lt;CancellationToken&gt;<br />static member DefaultCancellationToken : CancellationToken<br /><br />Full name: Microsoft.FSharp.Control.Async<br /><br />--------------------<br />type Async&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Control.Async&lt;_&gt;</div>
<div class="tip" id="fs17">module Array<br /><br />from Microsoft.FSharp.Collections</div>
<div class="tip" id="fs18">val filter : predicate:(&#39;T -&gt; bool) -&gt; array:&#39;T [] -&gt; &#39;T []<br /><br />Full name: Microsoft.FSharp.Collections.Array.filter</div>
<div class="tip" id="fs19">val not : value:bool -&gt; bool<br /><br />Full name: Microsoft.FSharp.Core.Operators.not</div>
<div class="tip" id="fs20">val ignore : value:&#39;T -&gt; unit<br /><br />Full name: Microsoft.FSharp.Core.Operators.ignore</div>
<div class="tip" id="fs21">val append : array1:&#39;T [] -&gt; array2:&#39;T [] -&gt; &#39;T []<br /><br />Full name: Microsoft.FSharp.Collections.Array.append</div>
<div class="tip" id="fs22">namespace System</div>
<div class="tip" id="fs23">namespace System.Threading</div>
<div class="tip" id="fs24">Multiple items<br />type CancellationToken =<br />&#160;&#160;struct<br />&#160;&#160;&#160;&#160;new : canceled:bool -&gt; CancellationToken<br />&#160;&#160;&#160;&#160;member CanBeCanceled : bool<br />&#160;&#160;&#160;&#160;member Equals : other:CancellationToken -&gt; bool + 1 overload<br />&#160;&#160;&#160;&#160;member GetHashCode : unit -&gt; int<br />&#160;&#160;&#160;&#160;member IsCancellationRequested : bool<br />&#160;&#160;&#160;&#160;member Register : callback:Action -&gt; CancellationTokenRegistration + 3 overloads<br />&#160;&#160;&#160;&#160;member ThrowIfCancellationRequested : unit -&gt; unit<br />&#160;&#160;&#160;&#160;member WaitHandle : WaitHandle<br />&#160;&#160;&#160;&#160;static member None : CancellationToken<br />&#160;&#160;end<br /><br />Full name: System.Threading.CancellationToken<br /><br />--------------------<br />System.Threading.CancellationToken()<br />System.Threading.CancellationToken(canceled: bool) : unit</div>
<div class="tip" id="fs25">property System.Threading.CancellationToken.None: System.Threading.CancellationToken</div>

</div>
<span class='st_reddit'></span>
<span class='st_facebook'></span>
<span class='st_twitter'></span>
<span class='st_linkedin'></span>
<span class='st_googleplus'></span>
<span class='st_tumblr'></span>
<span class='st_instapaper'></span>
<span class='st_email'></span>

    </section>
    <footer>
        <p><small>Hosted on Azure, using FsBlog. Because F# + Azure |> Jet <3.</small></p>
    </footer>
    <script src="http://tech.jet.com/javascripts/scale.fix.js"></script>
</body>
</html>
